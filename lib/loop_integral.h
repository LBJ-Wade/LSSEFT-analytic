//
// Created by David Seery on 30/08/2017.
// --@@
// Copyright (c) 2017 University of Sussex. All rights reserved.
//
// This file is part of the Sussex Effective Field Theory for
// Large-Scale Structure analytic calculation platform (LSSEFT-analytic).
//
// LSSEFT-analytic is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// LSSEFT-analytic is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with LSSEFT-analytic.  If not, see <http://www.gnu.org/licenses/>.
//
// @license: GPL-2
// @contributor: David Seery <D.Seery@sussex.ac.uk>
// --@@
//

#ifndef LSSEFT_ANALYTIC_LOOP_INTEGRAL_H
#define LSSEFT_ANALYTIC_LOOP_INTEGRAL_H


#include <iostream>

#include "shared/common.h"
#include "services/service_locator.h"
#include "utilities/GiNaC_utils.h"


//! forward-declare loop_integral
class loop_integral;

//! perform stream insertion
std::ostream& operator<<(std::ostream& str, const loop_integral& obj);


//! loop_integral captures the components needed to construct a component of a 2-point correlation function
class loop_integral
  {

    // CONSTRUCTOR, DESTRUCTOR

  public:

    //! constructor accepts a time function, momentum kernel, Wick product string, set of loop momenta,
    //! set of external momenta, set of Rayleigh momenta (and mappings), and a symbol factory.
    //! After construction, the variable names are canonicalized
    loop_integral(time_function tm_, GiNaC::ex K_, GiNaC::ex ws_, GiNaC_symbol_set lm_, GiNaC_symbol_set em_,
                  subs_list rm_, service_locator& lc_);

    //! destructor is default
    ~loop_integral() = default;


    // OPERATIONS

  public:

    //! increment in-place
    loop_integral& operator+=(const loop_integral& rhs);


    // METADATA

  public:

    //! get order in the loop expansion
    unsigned int get_loop_order() const { return static_cast<unsigned int>(this->loop_momenta.size()); }


    // INTEGRAND ACCESSORS

  public:

    //! get time function
    const time_function& get_time_function() const { return this->tm; }

    //! get momentum kernel
    const GiNaC::ex& get_kernel() const { return this->K; }

    //! get Wick product string
    const GiNaC::ex& get_Wick_product() const { return this->WickProduct; }

    //! get list of loop momenta
    const GiNaC_symbol_set& get_loop_momenta() const { return this->loop_momenta; }

    //! get list of Rayleigh momenta
    const subs_list& get_Rayleigh_momenta() const { return this->Rayleigh_momenta; }

    //! get list of external momenta
    const GiNaC_symbol_set& get_external_momenta() const { return this->external_momenta; }


    // TRANSFORMATIONS

  protected:

    //! convert loop momenta to a canonical form
    void canonicalize_loop_labels();

    //! convert Rayleigh momenta to a canonical form
    void canonicalize_Rayleigh_labels();

    //! match arguments of Wick products to Rayleigh momenta
    void match_Wick_to_Rayleigh();


    // SERVICES

  public:

    //! write self to stream
    void write(std::ostream& out) const;

    //! test whether another loop_integral object is of matching type
    //! (ie. shares time functiom, Wick product, loop momenta, external momenta, Rayleigh momenta)
    bool is_matching_type(const loop_integral& obj) const;;


    // INTERNAL DATA

  private:

    // DELEGATES

    //! cache reference to service locator
    service_locator& loc;


    // KERNEL DATA

    //! time function
    time_function tm;

    //! kernel
    GiNaC::ex K;

    //! string of 2pfs generated by Wick contraction
    GiNaC::ex WickProduct;

    //! set of loop momenta
    GiNaC_symbol_set loop_momenta;

    //! set of external momenta
    GiNaC_symbol_set external_momenta;

    //! set of momenta requiring Rayleigh expansion
    subs_list Rayleigh_momenta;


  };


//! loop_integral_key is a flyweight class that can turn a loop_integral
//! into a key for an (unordered) map
class loop_integral_key
  {

    // CONSTRUCTOR, DESTRUCTOR

  public:

    //! constructure captures a loop_integral instance
    loop_integral_key(const loop_integral& l);

    //! destructor is default
    ~loop_integral_key() = default;


    // INTERFACE

  public:

    //! hash ourselves
    size_t hash() const;

    //! test for equality
    bool is_equal(const loop_integral_key& obj) const;


    // INTERNAL DATA

  private:

    //! reference to loop_integral objects
    const loop_integral& loop;

  };


// specialize std::hash and std::equal_to work for loop_integral_key
namespace std
  {

    template <>
    struct hash<loop_integral_key>
      {
        size_t operator()(const loop_integral_key& key) const
          {
            return key.hash();
          }
      };


    template <>
    struct equal_to<loop_integral_key>
      {
        bool operator()(const loop_integral_key& a, const loop_integral_key& b) const
          {
            return a.is_equal(b);
          }
      };

  }


#endif //LSSEFT_ANALYTIC_LOOP_INTEGRAL_H
