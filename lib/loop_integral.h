//
// Created by David Seery on 30/08/2017.
// --@@
// Copyright (c) 2017 University of Sussex. All rights reserved.
//
// This file is part of the Sussex Effective Field Theory for
// Large-Scale Structure analytic calculation platform (LSSEFT-analytic).
//
// LSSEFT-analytic is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// LSSEFT-analytic is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with LSSEFT-analytic.  If not, see <http://www.gnu.org/licenses/>.
//
// @license: GPL-2
// @contributor: David Seery <D.Seery@sussex.ac.uk>
// --@@
//

#ifndef LSSEFT_ANALYTIC_LOOP_INTEGRAL_H
#define LSSEFT_ANALYTIC_LOOP_INTEGRAL_H


#include <iostream>

#include "shared/common.h"
#include "services/symbol_factory.h"
#include "utilities/GiNaC_utils.h"


//! forward-declare loop_integral
class loop_integral;

//! perform stream insertion
std::ostream& operator<<(std::ostream& str, const loop_integral& obj);


//! loop_integral captures the components needed to construct a component of a 2-point correlation function
class loop_integral
  {

    // CONSTRUCTOR, DESTRUCTOR

  public:

    //! constructor
    loop_integral(time_function tm_, GiNaC::ex K_, GiNaC::ex ws_, GiNaC_symbol_set lm_, GiNaC_symbol_set em_,
                  subs_list rm_, symbol_factory& sf_);

    //! destructor is default
    ~loop_integral() = default;


    // METADATA

  public:

    //! get order in the loop expansion
    unsigned int get_loop_order() const { return static_cast<unsigned int>(this->loop_momenta.size()); }


    // INTEGRAND ACCESSORS

  public:

    //! get time function
    const time_function& get_time_function() const { return this->tm; }

    //! get momentum kernel
    const GiNaC::ex& get_kernel() const { return this->K; }

    //! get Wick product string
    const GiNaC::ex& get_Wick_product() const { return this->WickProduct; }

    //! get list of loop momenta
    const GiNaC_symbol_set& get_loop_momenta() const { return this->loop_momenta; }

    //! get list of Rayleigh momenta
    const subs_list& get_Rayleigh_momenta() const { return this->Rayleigh_momenta; }

    //! get list of external momenta
    const GiNaC_symbol_set& get_external_momenta() const { return this->external_momenta; }


    // TRANSFORMATIONS

  protected:

    //! convert loop momenta to a canonical form
    void canonicalize_loop_labels();

    //! convert Rayleigh momenta to a canonical form
    void canonicalize_Rayleigh_labels();

    //! match arguments of Wick products to Rayleigh momenta
    void match_Wick_to_Rayleigh();


    // SERVICES

  public:

    //! write self to stream
    void write(std::ostream& out) const;


    // INTERNAL DATA

  private:

    // DELEGATES

    //! cache reference to symbol factory
    symbol_factory& sf;


    // KERNEL DATA

    //! time function
    time_function tm;

    //! kernel
    GiNaC::ex K;

    //! string of 2pfs generated by Wick contraction
    GiNaC::ex WickProduct;

    //! set of loop momenta
    GiNaC_symbol_set loop_momenta;

    //! set of external momenta
    GiNaC_symbol_set external_momenta;

    //! set of momenta requiring Rayleigh expansion
    subs_list Rayleigh_momenta;


  };


#endif //LSSEFT_ANALYTIC_LOOP_INTEGRAL_H
