//
// Created by David Seery on 05/04/2018.
// --@@
// Copyright (c) 2017 University of Sussex. All rights reserved.
//
// This file is part of the Sussex Effective Field Theory for
// Large-Scale Structure analytic calculation platform (LSSEFT-analytic).
//
// LSSEFT-analytic is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// LSSEFT-analytic is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with LSSEFT-analytic.  If not, see <http://www.gnu.org/licenses/>.
//
// @license: GPL-2
// @contributor: David Seery <D.Seery@sussex.ac.uk>
// --@@
//

#ifndef LSSEFT_ANALYTIC_TREE_EXPRESSION_H
#define LSSEFT_ANALYTIC_TREE_EXPRESSION_H


#include <iostream>

#include "shared/common.h"
#include "services/service_locator.h"
#include "utilities/GiNaC_utils.h"


//! tree_expression captures the components needed to evaluate a tree-level contribution to a correlation function
class tree_expression
  {

    // CONSTRUCTOR, DESTRUCTOR

  public:

    //! constructor accepts a time function, momentum kernel, Wick product string, set of external momenta,
    //! and a service locator.
    tree_expression(time_function tm_, GiNaC::ex K_, GiNaC::ex ws_, GiNaC_symbol_set em_,
                    service_locator& lc_);

    //! destructor is default
    ~tree_expression() = default;


    // OPERATIONS

  public:

    //! increment in-place
    tree_expression& operator+=(const tree_expression& rhs);


    // METADATA

  public:

    //! get order in the loop expression
    constexpr unsigned int get_loop_order() const { return 0; }


    // INTEGRAND ACCESSORS

  public:

    //! get time function
    const time_function& get_time_function() const { return this->tm; }

    //! get momentum kernel
    const GiNaC::ex& get_kernel() const { return this->K; }

    //! get Wick product string
    const GiNaC::ex& get_Wick_product() const { return this->WickProduct; }

    //! get list of external momenta
    const GiNaC_symbol_set& get_external_momenta() const { return this->external_momenta; }


    // SERVICES

  public:

    //! write self to stream
    void write(std::ostream& out) const;

    //! convert self to Mathematica format expression
    std::string to_Mathematica() const;

    //! test whether another tree_expression object is of matching type
    //! (ie. shares time functiom, Wick product, loop momenta, external momenta, Rayleigh momenta)
    bool is_matching_type(const tree_expression& obj) const;;


    // INTERNAL DATA

  private:

    // DELEGATES

    //! cache reference to service locator
    service_locator& loc;


    // KERNEL DATA

    //! time function
    time_function tm;

    //! kernel
    GiNaC::ex K;

    //! string of 2pfs generated by Wick contraction
    GiNaC::ex WickProduct;

    //! set of external momenta
    GiNaC_symbol_set external_momenta;


  };


//! perform stream insertion
std::ostream& operator<<(std::ostream& str, const tree_expression& obj);


//! tree_expression_key is a flyweight class that can turn a tree_expression
//! into a key for an (unordered) map
class tree_expression_key
  {

    // CONSTRUCTOR, DESTRUCTOR

  public:

    //! constructure captures a loop_integral instance
    tree_expression_key(const tree_expression& t);

    //! destructor is default
    ~tree_expression_key() = default;


    // INTERFACE

  public:

    //! hash ourselves
    size_t hash() const;

    //! test for equality
    bool is_equal(const tree_expression_key& obj) const;


    // INTERNAL DATA

  private:

    //! reference to loop_integral objects
    const tree_expression& tree;

  };


// specialize std::hash and std::equal_to work for oneloop_expression_key
namespace std
  {

    template <>
    struct hash<tree_expression_key>
      {
        size_t operator()(const tree_expression_key& key) const
          {
            return key.hash();
          }
      };


    template <>
    struct equal_to<tree_expression_key>
      {
        bool operator()(const tree_expression_key& a, const tree_expression_key& b) const
          {
            return a.is_equal(b);
          }
      };

  }


#endif //LSSEFT_ANALYTIC_TREE_EXPRESSION_H
