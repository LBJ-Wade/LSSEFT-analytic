//
// Created by David Seery on 30/08/2017.
// --@@
// Copyright (c) 2017 University of Sussex. All rights reserved.
//
// This file is part of the Sussex Effective Field Theory for
// Large-Scale Structure analytic calculation platform (LSSEFT-analytic).
//
// LSSEFT-analytic is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// LSSEFT-analytic is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with LSSEFT-analytic.  If not, see <http://www.gnu.org/licenses/>.
//
// @license: GPL-2
// @contributor: David Seery <D.Seery@sussex.ac.uk>
// --@@
//

#ifndef LSSEFT_ANALYTIC_LOOP_INTEGRAL_H
#define LSSEFT_ANALYTIC_LOOP_INTEGRAL_H


#include <iostream>

#include "shared/common.h"
#include "services/service_locator.h"
#include "utilities/GiNaC_utils.h"


//! oneloop_expression captures the components needed to evaluate a 1-loop level contribution to a correlation function
class oneloop_expression
  {

    // CONSTRUCTOR, DESTRUCTOR

  public:

    //! constructor accepts a time function, momentum kernel, Wick product string, set of loop momenta,
    //! set of external momenta, set of Rayleigh momenta (and mappings), and a service locator.
    //! After construction, the variable names are canonicalized
    oneloop_expression(time_function tm_, GiNaC::ex K_, GiNaC::ex ws_, GiNaC_symbol_set lm_, GiNaC_symbol_set em_,
                       subs_list rm_, service_locator& lc_);

    //! destructor is default
    ~oneloop_expression() = default;


    // OPERATIONS

  public:

    //! increment in-place
    oneloop_expression& operator+=(const oneloop_expression& rhs);


    // METADATA

  public:

    //! get order in the loop expansion
    unsigned int get_loop_order() const { return static_cast<unsigned int>(this->loop_momenta.size()); }


    // INTEGRAND ACCESSORS

  public:

    //! get time function
    const time_function& get_time_function() const { return this->tm; }

    //! get momentum kernel
    const GiNaC::ex& get_kernel() const { return this->K; }

    //! get Wick product string
    const GiNaC::ex& get_Wick_product() const { return this->WickProduct; }

    //! get list of loop momenta
    const GiNaC_symbol_set& get_loop_momenta() const { return this->loop_momenta; }

    //! get list of Rayleigh momenta
    const subs_list& get_Rayleigh_momenta() const { return this->Rayleigh_momenta; }

    //! get list of external momenta
    const GiNaC_symbol_set& get_external_momenta() const { return this->external_momenta; }


    // TRANSFORMATIONS

  public:

    //! apply simplification map
    void simplify(const GiNaC::exmap& map);

    //! canonicalize external momenta by converting any angular products involving them to
    //! cosines rather than Legendre polynomials
    void canonicalize_external_momenta();

  protected:

    //! convert loop momenta to a canonical form
    void canonicalize_loop_labels();

    //! convert Rayleigh momenta to a canonical form
    void canonicalize_Rayleigh_labels();

    //! match arguments of Wick products to Rayleigh momenta
    void match_Wick_to_Rayleigh();


    // SERVICES

  public:

    //! write self to stream
    void write(std::ostream& out) const;

    //! test whether another loop_integral object is of matching type
    //! (ie. shares time functiom, Wick product, loop momenta, external momenta, Rayleigh momenta)
    bool is_matching_type(const oneloop_expression& obj) const;;


    // INTERNAL DATA

  private:

    // DELEGATES

    //! cache reference to service locator
    service_locator& loc;


    // KERNEL DATA

    //! time function
    time_function tm;

    //! kernel
    GiNaC::ex K;

    //! string of 2pfs generated by Wick contraction
    GiNaC::ex WickProduct;

    //! set of loop momenta
    GiNaC_symbol_set loop_momenta;

    //! set of external momenta
    GiNaC_symbol_set external_momenta;

    //! set of momenta requiring Rayleigh expansion
    subs_list Rayleigh_momenta;


  };


//! perform stream insertion
std::ostream& operator<<(std::ostream& str, const oneloop_expression& obj);


//! oneloop_expression_key is a flyweight class that can turn a oneloop_expression
//! into a key for an (unordered) map
class oneloop_expression_key
  {

    // CONSTRUCTOR, DESTRUCTOR

  public:

    //! constructure captures a loop_integral instance
    oneloop_expression_key(const oneloop_expression& l);

    //! destructor is default
    ~oneloop_expression_key() = default;


    // INTERFACE

  public:

    //! hash ourselves
    size_t hash() const;

    //! test for equality
    bool is_equal(const oneloop_expression_key& obj) const;


    // INTERNAL DATA

  private:

    //! reference to loop_integral objects
    const oneloop_expression& loop;

  };


// specialize std::hash and std::equal_to work for oneloop_expression_key
namespace std
  {

    template <>
    struct hash<oneloop_expression_key>
      {
        size_t operator()(const oneloop_expression_key& key) const
          {
            return key.hash();
          }
      };


    template <>
    struct equal_to<oneloop_expression_key>
      {
        bool operator()(const oneloop_expression_key& a, const oneloop_expression_key& b) const
          {
            return a.is_equal(b);
          }
      };

  }


#endif //LSSEFT_ANALYTIC_LOOP_INTEGRAL_H
